Hello World!
	-> After a year at Novamens, I moved to Inaka where I work since almost 2 years ago
Inaka
	-> So, what are we going to talk about today?
Introduction
	- It's a design pattern we keep seeing everywhere
	- API is good for integration, Sockets are good for real-time
	-> And what are we going to do with a sysem like that?
Scope
	-> To show you all this process, I created a sample project
		very very similar to the ones we develop @ Inaka all the time
MS: General Idea
	-> So, what are the requirements of a system like this one?
MS: Reqs
	- Erlang seems to be the best language to develop this system with
	-> Well, let's start by designing it
MS: Design
	[ Show each element ]
	-> Let's see how it looks in terms of Erlang processes
MS: Architecture
	- This is a general view
	- A regular Erlang application
	-> Let's see each component in deeper detail
MS: Components
	- I'm assuming here, you're all familiar with application and main supervisor process so I'll just skip those
	-> Great! A good design, we used Erlang, we used OTP… what can possibly go wrong, right?
Lesson
	- Turns out that…
	-> So, let's see how much can our system scale, right?
Measures
	-> To get those measures, we will use these tools (and some others)
Tools
	-> Great! We have our tools, we have our target… let's get started, shall we?
S0: Baseline
	- Note: we want to test it in its local network to prevent the network itself to intervene in our mesurements, but since we're using a local network we know we should aim for better values than the ones we need
	-> Now, so we test the system… and what do we find? Millions of users? Hundreds of Thousands of users? Well, actually…
S0: Results
	- That's NOT a typo: it says 26 SECONDS… in a LOCAL NETWORK
	-> That's just wrong, man. But the system was correctly designed and implemented, there must be something wrong with the machine where we installed it
S1: OS Tune
	- Most server OSs are designed to be "general-purpose"… we need to "let them know" what we plan to use them for
	- These things are usually set by kernel variables or startup parameters (for Erlang VM). You have a very comprehensive list of those in Inaka's Blog
	-> Now let's bet again, with all those tweaks, what do we get?
S1: Results
	- N improved 4x
	- but ART is EVEN WORST!
	-> We can't blame the machine anymore, we should start improving our own system
...
S2.1: {client_listener, start_link, [I]}
	-> Let's see the resulting system architecture after those changes
S2.1: Arch
	-> Ok, did we improve anything with it?
S2.1: Results
	- N improved 2x, but C improved 20x and ART is less than half of what it was before
	-> Can we improve it further, let's try with gen_events
...
S2.2: repeater Code
	-> Let's see the resulting system architecture after those changes
S2.2: Arch
	-> Ok, did we improve anything with it?
S2.2: Results
	- N stayed the same
	- but C is 2x
	- and, most importantly we reduced the ART almost 8x
	-> Let's tackle another ubiquitous behavior: gen_server
...
S2.3: init 0 and timeout Code
	-> We didn't do any architecture changes this time, so let's just jump to the results
S2.3: Results
	- N 5x
	- C 5x
	- ART almost 100x
	-> Let's aim now for the supervisors
...
S2.4: supervisors Code [NOTE: 2 SLIDES]
	-> Let's see the resulting system architecture after this change
S2.4: Arch
	-> Ok, now to the results
S2.4: Results
	- N 10K+
	- C 3K+
	-> And finally, let's see some other improvements we can make
S2.5: Logging
	-> I won't show code on this one, because [TODO]
...
S2.5: Code
	-> We didn't do any architecture changes this time, so let's just jump to the results
S2.5: Results
	- Well, we reduce ART to less than its half and we have now an acceptable system
	-> Let's see if we can add some nodes to it


